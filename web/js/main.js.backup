/**
 * E-Commerce Frontend JavaScript
 */

// API base URL
const API_BASE_URL = "/api/v1";

// Helper function for making API requests
async function fetchApi(endpoint, options = {}) {
  const token = localStorage.getItem("token");

  // Check if token is expired and try to refresh it
  if (token && auth.isTokenExpired()) {
    console.log("Token expired before request, attempting to refresh");
    // auth.logout();
    // throw new Error("Your session has expired. Please log in again.");
  }

  const defaultOptions = {
    headers: {
      "Content-Type": "application/json",
      ...(token && { Authorization: `Bearer ${token}` }),
    },
  };

  const requestOptions = {
    ...defaultOptions,
    ...options,
  };

  console.log(`API Request: ${endpoint}`, {
    method: requestOptions.method || "GET",
    headers: requestOptions.headers,
    hasBody: !!requestOptions.body,
  });

  try {
    const response = await fetch(`${API_BASE_URL}${endpoint}`, requestOptions);

    // Try to parse the response as JSON
    let data;
    const contentType = response.headers.get("content-type");
    if (contentType && contentType.includes("application/json")) {
      data = await response.json();
    } else {
      data = await response.text();
    }

    console.log(`API Response: ${endpoint}`, {
      status: response.status,
      ok: response.ok,
      contentType,
      data,
    });

    if (!response.ok) {
      const errorMessage =
        typeof data === "object" && data.message
          ? data.message
          : `API error: ${response.status}`;

      // Handle authentication errors
      if (
        response.status === 401 ||
        (typeof data === "object" &&
          data.code === "ERROR" &&
          (data.message === "Invalid token" || data.message.includes("token")))
      ) {
        console.error("Authentication error:", data);
        // auth.logout();
        throw new Error("Your session has expired. Please log in again.");
      }

      throw new Error(errorMessage);
    }

    return data;
  } catch (error) {
    console.error(`API Error: ${endpoint}`, error);
    throw error;
  }
}

// Authentication functions
const auth = {
  // Login user
  async login(email, password) {
    console.log("Login attempt for:", email);

    try {
      const response = await fetchApi("/auth/login", {
        method: "POST",
        body: JSON.stringify({ email, password }),
      });

      console.log("Login API response:", response);

      // Handle the API response format: { code, data: { access_token, refresh_token, expires_in }, message, server_time }
      if (response.data && response.data.access_token) {
        localStorage.setItem("token", response.data.access_token);
        if (response.data.refresh_token) {
          localStorage.setItem("refresh_token", response.data.refresh_token);
        }

        // Store token expiration time
        if (response.data.expires_in) {
          const expiresAt = Date.now() + response.data.expires_in * 1000;
          localStorage.setItem("token_expires_at", expiresAt.toString());
        }

        // If there's user data in the response, store it
        if (response.data.user) {
          localStorage.setItem("user", JSON.stringify(response.data.user));
        } else {
          // Create a minimal user object to ensure we have something in storage
          const userObj = { email: email };
          localStorage.setItem("user", JSON.stringify(userObj));
        }

        console.log(
          "Login successful, token saved:",
          response.data.access_token
        );
        return response.data;
      } else if (response.code === "SUCCESS" && response.data) {
        // Try alternate format where data might contain the token directly
        console.log("Trying alternate response format");

        if (response.data.access_token) {
          localStorage.setItem("token", response.data.access_token);
          localStorage.setItem("user", JSON.stringify({ email: email }));
          console.log("Login successful with alternate format");
          return response.data;
        }
      }

      console.error("Invalid login response format:", response);
      throw new Error("Invalid login response format");
    } catch (error) {
      console.error("Login error:", error);
      throw error;
    }
  },

  // Refresh token
  async refreshToken() {
    const refreshToken = localStorage.getItem("refresh_token");
    if (!refreshToken) {
      return false;
    }

    try {
      const response = await fetchApi("/auth/refresh", {
        method: "POST",
        body: JSON.stringify({ refresh_token: refreshToken }),
      });

      if (response.data && response.data.access_token) {
        localStorage.setItem("token", response.data.access_token);

        // Update expiration time
        if (response.data.expires_in) {
          const expiresAt = Date.now() + response.data.expires_in * 1000;
          localStorage.setItem("token_expires_at", expiresAt.toString());
        }

        console.log("Token refreshed successfully");
        return true;
      }

      return false;
    } catch (error) {
      console.error("Token refresh failed:", error);
      return false;
    }
  },

  // Check if token has expired
  isTokenExpired() {
    const expiresAt = localStorage.getItem("token_expires_at");
    if (!expiresAt) return false;

    // Return true if token expiration time is in the past
    return Date.now() > parseInt(expiresAt, 10);
  },

  // Register new user
  async register(userData) {
    return fetchApi("/auth/register", {
      method: "POST",
      body: JSON.stringify(userData),
    });
  },

  // Logout user
  logout() {
    console.log("Logging out user");
    localStorage.removeItem("token");
    localStorage.removeItem("refresh_token");
    localStorage.removeItem("token_expires_at");
    localStorage.removeItem("user");
    window.location.href = "login.html";
  },

  // Get current user
  getCurrentUser() {
    const userJson = localStorage.getItem("user");
    return userJson ? JSON.parse(userJson) : null;
  },

  // Check if user is logged in
  isLoggedIn() {
    const hasToken = !!localStorage.getItem("token");

    // If we have a token but it's expired, try to refresh it
    if (hasToken && this.isTokenExpired()) {
      console.log("Token expired, attempting to refresh");
      // Note: we don't await this because we want a synchronous response,
      // the token will be refreshed in the background
      this.refreshToken().then((success) => {
        if (!success) {
          // If refresh fails, force logout
          //   this.logout();
        }
      });
    }

    return hasToken;
  },
};

// Product functions
const products = {
  // Get all products
  async getAll() {
    try {
      console.log("Fetching products from API...");
      const response = await fetchApi("/products");
      console.log("Raw API response for products:", response);
      return response;
    } catch (error) {
      console.error("Error fetching products:", error);
      throw error;
    }
  },

  // Get product by ID
  async getById(id) {
    try {
      return await fetchApi(`/products/${id}`);
    } catch (error) {
      console.error(`Error fetching product ${id}:`, error);
      throw error;
    }
  },
};

// Cart functions
const cart = {
  // Get user's cart
  async getCart() {
    if (!auth.isLoggedIn()) return null;

    try {
      console.log("Fetching user cart...");
      const response = await fetchApi("/carts/me");
      console.log("Raw API response for cart:", response);
      return response;
    } catch (error) {
      console.error("Error fetching cart:", error);

      // If unauthorized, force logout
      if (error.message.includes("session has expired")) {
        // auth.logout();
        return null;
      }

      // If cart not found (404), return null instead of throwing
      if (error.message.includes("404")) {
        console.log("No cart found for user, will create a new one");
        return null;
      }

      return null;
    }
  },

  // Create a new cart
  async createCart() {
    try {
      console.log("Creating new cart...");
      const response = await fetchApi("/carts", {
        method: "POST",
        body: JSON.stringify({}),
      });
      console.log("Cart creation response:", response);
      return response;
    } catch (error) {
      console.error("Error creating cart:", error);

      // If unauthorized, force logout
      if (error.message.includes("session has expired")) {
        // auth.logout();
      }

      throw error;
    }
  },

  // Add item to cart
  async addToCart(cartId, productId, quantity = 1) {
    try {
      console.log(`Adding product ${productId} to cart ${cartId}...`);
      const response = await fetchApi(`/carts/${cartId}/items`, {
        method: "POST",
        body: JSON.stringify({
          product_id: productId,
          quantity: quantity,
        }),
      });
      console.log("Add to cart response:", response);
      return response;
    } catch (error) {
      console.error(`Error adding product ${productId} to cart:`, error);
      throw error;
    }
  },

  // Add item to current user's cart
  async addToCurrentUserCart(productId, quantity = 1) {
    try {
      console.log(`Adding product ${productId} to current user's cart...`);

      // Add additional debugging to inspect response
      const response = await fetchApi(`/carts/me`, {
        method: "POST",
        body: JSON.stringify({
          product_id: productId,
          quantity: quantity,
        }),
      });

      console.log("Add to current user's cart response:", response);
      return response;
    } catch (error) {
      console.error(
        `Error adding product ${productId} to current user's cart:`,
        error
      );

      // Check if it's a known error that we can recover from
      if (
        error.message &&
        (error.message.includes("cart item") ||
          error.message.includes("already exists") ||
          error.message.includes("deleted_at"))
      ) {
        console.warn(
          "Detected possible soft delete issue, trying fallback approach..."
        );

        try {
          // Get current cart to get its ID
          const cartResponse = await fetchApi("/carts/me");
          const cartId = cartResponse.data.id;

          // Try direct endpoint instead
          console.log(`Trying direct endpoint for cart ${cartId}...`);
          const directResponse = await fetchApi(`/carts/${cartId}/items`, {
            method: "POST",
            body: JSON.stringify({
              product_id: productId,
              quantity: quantity,
            }),
          });

          console.log("Direct endpoint response:", directResponse);
          return directResponse;
        } catch (fallbackError) {
          console.error("Fallback approach failed:", fallbackError);
          throw fallbackError;
        }
      }

      throw error;
    }
  },

  // Remove item from cart
  async removeFromCart(cartId, itemId) {
    try {
      console.log(`Removing item ${itemId} from cart ${cartId}...`);
      const response = await fetchApi(`/carts/${cartId}/items/${itemId}`, {
        method: "DELETE",
      });
      console.log("Remove from cart response:", response);
      return response;
    } catch (error) {
      console.error(`Error removing item ${itemId} from cart:`, error);
      throw error;
    }
  },

  // Update cart item quantity
  async updateCartItem(cartId, itemId, quantity) {
    try {
      console.log(
        `Updating item ${itemId} in cart ${cartId} to quantity ${quantity}...`
      );
      const response = await fetchApi(`/carts/${cartId}/items/${itemId}`, {
        method: "PUT",
        body: JSON.stringify({
          quantity: quantity,
        }),
      });
      console.log("Update cart item response:", response);
      return response;
    } catch (error) {
      console.error(`Error updating item ${itemId} in cart:`, error);
      throw error;
    }
  },
};

// Form validation functions
const validateEmail = (email) => {
  const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return re.test(String(email).toLowerCase());
};

// Initialize page-specific functionality
function initPage() {
  // Update navigation links
  updateNavigation();

  // Determine which page we're on and initialize accordingly
  const path = window.location.pathname;

  // Check if user is logged in
  const isLoggedIn = auth.isLoggedIn();

  // Redirect to appropriate pages based on auth status
  if (isLoggedIn) {
    if (path.includes("login.html") || path.includes("register.html")) {
      window.location.href = "products.html";
      return;
    }
  } else {
    // Redirect to login if not authenticated (except for login, register, index, and products pages)
    if (
      path.includes("cart.html") ||
      (!path.includes("login.html") &&
      !path.includes("register.html") &&
      !path.includes("index.html") &&
      !path.includes("products.html") &&
      path !== "/" &&
      path !== "")
    ) {
      window.location.href = "login.html";
      return;
    }
  }

  // Initialize page-specific functions
  if (path.includes("login.html")) {
    initLoginPage();
  } else if (path.includes("register.html")) {
    initRegisterPage();
  } else if (path.includes("products.html")) {
    initProductsPage();
  } else if (path.includes("cart.html")) {
    if (isLoggedIn) {
      initCartPage();
    } else {
      window.location.href = "login.html";
    }
  } else if (path.includes("checkout.html")) {
    if (isLoggedIn) {
      initCheckoutPage();
    } else {
      window.location.href = "login.html";
    }
  } else if (path.includes("index.html") || path === "/" || path === "") {
    initHomePage();
  }
}

// Update navigation based on authentication status
function updateNavigation() {
  // Get all navigation containers across different pages
  const navElements = document.querySelectorAll("header nav .flex");
  if (navElements.length === 0) return;
  
  const currentPath = window.location.pathname;
  const isProductsPage = currentPath.includes('products.html');
  const isLoginPage = currentPath.includes('login.html');
  const isRegisterPage = currentPath.includes('register.html');
  const isCartPage = currentPath.includes('cart.html');
  
  if (auth.isLoggedIn()) {
    // User is logged in - show Products, Cart, Logout
    navElements.forEach(function(nav) {
      nav.innerHTML = 
        '<a href="products.html" class="text-gray-600 hover:text-gray-900 ' + (isProductsPage ? 'text-gray-900 font-medium' : '') + '">Products</a>' +
        '<a href="cart.html" class="text-gray-600 hover:text-gray-900 ' + (isCartPage ? 'text-gray-900 font-medium' : '') + '">Cart</a>' +
        '<a href="#" id="logout-link" class="text-gray-600 hover:text-gray-900">Logout</a>';
    });

    // Add logout listeners to all logout links
    var logoutLinks = document.querySelectorAll("#logout-link");
    for (var i = 0; i < logoutLinks.length; i++) {
      logoutLinks[i].addEventListener("click", function(e) {
        e.preventDefault();
        console.log("Logout clicked");
        auth.logout();
      });
    }
  } else {
    // User is not logged in - show Products, Login, Register
    navElements.forEach(function(nav) {
      nav.innerHTML = 
        '<a href="products.html" class="text-gray-600 hover:text-gray-900 ' + (isProductsPage ? 'text-gray-900 font-medium' : '') + '">Products</a>' +
        '<a href="login.html" class="text-gray-600 hover:text-gray-900 ' + (isLoginPage ? 'text-gray-900 font-medium' : '') + '">Login</a>' +
        '<a href="register.html" class="text-gray-600 hover:text-gray-900 ' + (isRegisterPage ? 'text-gray-900 font-medium' : '') + '">Register</a>';
    });
  }
}

// Initialize login page
function initLoginPage() {
  const loginForm = document.getElementById("login-form");
  if (!loginForm) return;

  // Add a status element for feedback
  const statusDiv = document.createElement("div");
  statusDiv.id = "login-status";
  statusDiv.style.marginTop = "10px";
  statusDiv.style.padding = "10px";
  statusDiv.style.borderRadius = "4px";
  statusDiv.style.display = "none";
  loginForm.appendChild(statusDiv);

  loginForm.addEventListener("submit", async (e) => {
    e.preventDefault();

    const email = document.getElementById("email").value;
    const password = document.getElementById("password").value;

    // Clear any previous status
    statusDiv.textContent = "";
    statusDiv.style.display = "none";
    statusDiv.className = "";

    // Show loading status
    statusDiv.textContent = "Logging in...";
    statusDiv.style.display = "block";
    statusDiv.style.backgroundColor = "#f8f9fa";
    statusDiv.style.color = "#333";

    try {
      const result = await auth.login(email, password);

      // Show success message
      statusDiv.textContent = "Login successful! Redirecting...";
      statusDiv.style.backgroundColor = "#d4edda";
      statusDiv.style.color = "#155724";

      console.log("Login successful, redirecting to products page");
      setTimeout(() => {
        window.location.href = "products.html";
      }, 1000); // Short delay to show success message
    } catch (error) {
      // Show error message
      console.error("Login error:", error);
      statusDiv.textContent =
        error.message || "Login failed. Please try again.";
      statusDiv.style.backgroundColor = "#f8d7da";
      statusDiv.style.color = "#721c24";
    }
  });
}

// Initialize register page
function initRegisterPage() {
  const registerForm = document.getElementById("register-form");
  if (!registerForm) return;

  registerForm.addEventListener("submit", async (e) => {
    e.preventDefault();

    const name = document.getElementById("name").value;
    const email = document.getElementById("email").value;
    const password = document.getElementById("password").value;

    if (!validateEmail(email)) {
      alert("Please enter a valid email address");
      return;
    }

    try {
      await auth.register({ name, email, password });
      alert("Registration successful! Please log in.");
      window.location.href = "login.html";
    } catch (error) {
      alert(error.message || "Registration failed. Please try again.");
    }
  });
}

// Initialize products page
async function initProductsPage() {
  const productGrid = document.querySelector(".product-grid");
  if (!productGrid) return;

  // Show loading state
  productGrid.innerHTML =
    '<div class="loading-spinner">Loading products...</div>';

  try {
    const response = await products.getAll();
    console.log("Products API response:", response);

    // Handle different response structures
    let productList = [];

    // Check for response format: { code, data: { products: [...] }, message }
    if (
      response &&
      response.data &&
      response.data.products &&
      Array.isArray(response.data.products)
    ) {
      productList = response.data.products;
    }
    // Check for standard API response format: { code, data: [...], message }
    else if (response && response.data && Array.isArray(response.data)) {
      productList = response.data;
    }
    // Check if response itself is an array
    else if (Array.isArray(response)) {
      productList = response;
    }
    // Check if response has items property
    else if (response && response.items && Array.isArray(response.items)) {
      productList = response.items;
    }
    // Check if response has product_list property
    else if (
      response &&
      response.product_list &&
      Array.isArray(response.product_list)
    ) {
      productList = response.product_list;
    }
    // No valid products found
    else {
      console.error("Unexpected API response format:", response);
      productGrid.innerHTML =
        '<p class="text-center">No products available. Unexpected data format.</p>';
      return;
    }

    if (productList.length === 0) {
      productGrid.innerHTML =
        '<p class="text-center">No products available</p>';
      return;
    }

    // Log the product data structure to help debugging
    console.log("First product data structure:", productList[0]);

    productGrid.innerHTML = productList
      .map((product) => {
        // Extract product properties safely
        const name = product.name || product.product_name || "Unnamed Product";
        const price = product.price || product.unit_price || 0;
        const inventory =
          product.inventory_quantity || product.stock || product.inventory || 0;
        const id = product.id || product.product_id || "";
        const imageUrl =
          product.image_url || product.image || "img/product-placeholder.svg";

        return `
      <div class="product-card">
        <div class="product-image">
          <img src="${imageUrl}" alt="${name}">
        </div>
        <div class="product-info">
          <h3 class="product-name">${name}</h3>
          <p class="product-price">$${parseFloat(price).toFixed(2)}</p>
          <p class="product-inventory">In stock: ${inventory}</p>
          <button class="btn btn-block add-to-cart" data-product-id="${id}">Add to Cart</button>
        </div>
      </div>
      `;
      })
      .join("");

    // Add event listeners for add to cart buttons
    document.querySelectorAll(".add-to-cart").forEach((button) => {
      button.addEventListener("click", async () => {
        if (!auth.isLoggedIn()) {
          window.location.href = "login.html";
          return;
        }

        const productId = button.dataset.productId;
        const originalText = button.textContent;

        // Show loading state
        button.textContent = "Adding...";
        button.disabled = true;

        try {
          // First try to add to current user's cart directly
          try {
            await cart.addToCurrentUserCart(productId, 1);
            button.textContent = "Added!";
            setTimeout(() => {
              button.textContent = originalText;
              button.disabled = false;
            }, 2000);
            return;
          } catch (directAddError) {
            console.log(
              "Could not add directly to user cart, trying fallback method...",
              directAddError
            );

            // If the error contains specific messages, we might need to handle differently
            if (
              directAddError.message &&
              directAddError.message.includes("already exists")
            ) {
              // This might be a soft-deleted item issue, try to force a refresh
              button.textContent = "Added!";
              setTimeout(() => {
                button.textContent = originalText;
                button.disabled = false;
              }, 2000);
              return;
            }
          }

          // Fallback: Get or create cart
          let userCart = await cart.getCart();
          if (!userCart) {
            console.log("Creating new cart as fallback...");
            userCart = await cart.createCart();
          }

          if (!userCart || !userCart.id) {
            throw new Error(
              "Could not access or create your cart. Please try logging in again."
            );
          }

          await cart.addToCart(userCart.id, productId, 1);
          button.textContent = "Added!";
          setTimeout(() => {
            button.textContent = originalText;
            button.disabled = false;
          }, 2000);
        } catch (error) {
          console.error("Add to cart error:", error);
          button.textContent = "Failed";

          // Show more specific error message to help with debugging
          let errorMsg = "Failed to add product to cart";
          if (error.message) {
            errorMsg += `: ${error.message}`;
          }

          alert(errorMsg);

          setTimeout(() => {
            button.textContent = originalText;
            button.disabled = false;
          }, 2000);
        }
      });
    });
  } catch (error) {
    console.error("Error loading products:", error);
    productGrid.innerHTML = `<p class="text-center">Error loading products: ${error.message}</p>`;
  }
}

// Initialize cart page
async function initCartPage() {
  const cartItemsContainer = document.getElementById("cart-items");
  if (!cartItemsContainer) return;

  // Show loading state
  cartItemsContainer.innerHTML =
    '<div class="p-6 text-center text-gray-500"><i class="fas fa-spinner fa-spin mr-2"></i>Loading your cart...</div>';

  try {
    const response = await cart.getCart();
    console.log("Cart API response:", response);

    // Handle different response structures
    let userCart = null;

    // Check for standard API response format: { code, data: {...}, message }
    if (response && response.data) {
      userCart = response.data;
    }
    // Check if response itself is a cart object
    else if (response && response.id) {
      userCart = response;
    }

    // If no cart exists yet, show empty cart message
    if (!userCart) {
      cartItemsContainer.innerHTML = `
        <div class="p-8 text-center">
          <div class="text-gray-500 mb-4"><i class="fas fa-shopping-cart text-4xl mb-4"></i></div>
          <p class="text-lg text-gray-700 mb-4">Keranjang anda masih kosong</p>
          <a href="products.html" class="inline-flex items-center bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md">
            <i class="fas fa-shopping-bag mr-2"></i> Lihat Produk
          </a>
        </div>
      `;
      updateCartSummary(0, 0, 0);
      return;
    }

    // Extract cart items safely
    let cartItems = [];
    if (userCart.items && Array.isArray(userCart.items)) {
      cartItems = userCart.items;
    } else if (userCart.cart_items && Array.isArray(userCart.cart_items)) {
      cartItems = userCart.cart_items;
    }

    if (cartItems.length === 0) {
      cartItemsContainer.innerHTML = `
        <div class="p-8 text-center">
          <div class="text-gray-500 mb-4"><i class="fas fa-shopping-cart text-4xl mb-4"></i></div>
          <p class="text-lg text-gray-700 mb-4">Keranjang anda masih kosong</p>
          <a href="products.html" class="inline-flex items-center bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md">
            <i class="fas fa-shopping-bag mr-2"></i> Lihat Produk
          </a>
        </div>
      `;
      updateCartSummary(0, 0, 0);
      return;
    }

    let subtotal = 0;

    // Check if we have a custom template function defined in cart.html
    if (
      window.cartItemTemplate &&
      typeof window.cartItemTemplate === "function"
    ) {
      const itemsHtml = cartItems
        .map((item) => {
          // Extract item properties safely
          const product = item.product || {};
          const name = product.name || item.product_name || "Unnamed Product";
          const price = product.price || item.unit_price || 0;
          const quantity = item.quantity || 1;
          const itemId = item.id || item.item_id || "";
          const maxQuantity = product.inventory || 10; // Default to 10 if inventory unknown
          const sku = product.sku || item.product_sku || "";
          const imageUrl =
            product.image_url || product.image || "img/product-placeholder.png";

          const itemTotal = quantity * price;
          subtotal += itemTotal;

          // Use the custom template
          return window.cartItemTemplate({
            id: itemId,
            quantity: quantity,
            product: {
              id: product.id || "",
              name: name,
              price: price,
              sku: sku,
              image: imageUrl,
              inventory: maxQuantity,
            },
          });
        })
        .join("");

      // Insert cart items HTML
      cartItemsContainer.innerHTML = itemsHtml;
    } else {
      // Use the fallback template
      const itemsHtml = cartItems
        .map((item) => {
          // Extract item properties safely
          const product = item.product || {};
          const name = product.name || item.product_name || "Unnamed Product";
          const price = product.price || item.unit_price || 0;
          const quantity = item.quantity || 1;
          const itemId = item.id || item.item_id || "";
          const maxQuantity = product.inventory || 10; // Default to 10 if inventory unknown
          const sku = product.sku || item.product_sku || "";
          const imageUrl =
            product.image_url || product.image || "img/product-placeholder.png";

          const itemTotal = quantity * price;
          subtotal += itemTotal;

          return `
          <div class="cart-item p-4 border-b border-gray-200" data-item-id="${itemId}">
            <div class="flex flex-col sm:flex-row">
              <div class="flex-shrink-0 w-full sm:w-24 h-24 bg-gray-100 rounded-md overflow-hidden mb-4 sm:mb-0">
                <img src="${imageUrl}" alt="${name}" class="w-full h-full object-contain p-2">
              </div>
              <div class="flex-grow sm:ml-4">
                <div class="flex flex-col sm:flex-row justify-between">
                  <div>
                    <h3 class="text-base font-medium text-gray-800">${name}</h3>
                    ${
                      sku
                        ? `<p class="text-sm text-gray-500">SKU: ${sku}</p>`
                        : ""
                    }
                    <p class="text-base font-medium text-green-600 mt-1">${formatPrice(
                      price
                    )}</p>
                  </div>
                  <div class="flex items-center mt-4 sm:mt-0">
                    <div class="flex border border-gray-300 rounded-md">
                      <button class="decrease-quantity-btn px-3 py-1 text-gray-600 hover:bg-gray-100" data-item-id="${itemId}" ${
            quantity <= 1 ? "disabled" : ""
          }>
                        <i class="fas fa-minus"></i>
                      </button>
                      <input type="number" min="1" value="${quantity}" class="quantity-input w-12 text-center border-x border-gray-300" data-item-id="${itemId}">
                      <button class="increase-quantity-btn px-3 py-1 text-gray-600 hover:bg-gray-100" data-item-id="${itemId}" ${
            quantity >= maxQuantity ? "disabled" : ""
          }>
                        <i class="fas fa-plus"></i>
                      </button>
                    </div>
                    <button class="remove-item-btn ml-3 text-red-500 hover:text-red-700" data-item-id="${itemId}">
                      <i class="fas fa-trash-alt"></i>
                    </button>
                  </div>
                </div>
                <div class="mt-3">
                  <p class="text-gray-600 text-sm">Subtotal: <span class="font-medium">${formatPrice(
                    itemTotal
                  )}</span></p>
                </div>
              </div>
            </div>
          </div>
        `;
        })
        .join("");

      // Insert cart items HTML
      cartItemsContainer.innerHTML = itemsHtml;
    }

    // Check for promotions and display them
    const hasPromotions =
      userCart.applicable_promotions &&
      userCart.applicable_promotions.length > 0;
    const discount = hasPromotions
      ? parseFloat(userCart.potential_discount || 0)
      : 0;
    const finalTotal = subtotal - discount;

    // Update the cart summary
    updateCartSummary(subtotal, discount, finalTotal);

    // Show promotions if available
    if (hasPromotions) {
      const discountSection = document.getElementById("discount-section");
      const discountItems = document.getElementById("discount-items");

      if (discountSection) {
        discountSection.classList.remove("hidden");
      }

      if (discountItems) {
        const promotionsHtml = userCart.applicable_promotions
          .map((promo) => {
            const promoDiscount = parseFloat(promo.discount || 0);
            return `
              <div class="flex justify-between text-sm">
                <span>${promo.description || "Diskon"}</span>
                <span class="font-medium">-${formatPrice(promoDiscount)}</span>
              </div>
            `;
          })
          .join("");

        discountItems.innerHTML = promotionsHtml;
      }
    }

    // Add event listeners for quantity controls
    setupCartItemEventListeners(cartItems, userCart);

    // Function to update the cart total
    function updateCartTotal() {
      let newTotal = 0;
      document.querySelectorAll(".cart-item").forEach((item) => {
        const subtotalText = item.querySelector(
          ".cart-item-subtotal span:last-child"
        ).textContent;
        const subtotal = parseFloat(
          subtotalText.replace("USD", "").replace(/\./g, "").replace(",", ".")
        );
        newTotal += subtotal;
      });

      // Check for promotions and calculate discount
      let discount = 0;
      if (
        userCart.applicable_promotions &&
        userCart.applicable_promotions.length > 0
      ) {
        // For simplicity, we'll use the same discount percentage as before
        // In a real app, you would recalculate promotions based on new quantities
        const originalDiscount = parseFloat(userCart.potential_discount || 0);
        const originalSubtotal = parseFloat(userCart.subtotal || 0);

        if (originalSubtotal > 0) {
          const discountRate = originalDiscount / originalSubtotal;
          discount = newTotal * discountRate;
        }
      }

      const finalTotal = Math.max(0, newTotal - discount);

      // Update summary
      updateCartSummary(newTotal, discount, finalTotal);
    }

    // Function to update cart summary
    function updateCartSummary(subtotal, discount, total) {
      const subtotalEl = document.getElementById("cart-subtotal");
      const discountEl = document.getElementById("cart-discount");
      const totalEl = document.getElementById("cart-final-total");

      if (subtotalEl) subtotalEl.textContent = formatPrice(subtotal);
      if (discountEl) discountEl.textContent = `-${formatPrice(discount)}`;
      if (totalEl) totalEl.textContent = formatPrice(total);
    }

    // Setup cart item event listeners
    function setupCartItemEventListeners(cartItems, userCart) {
      // Handle quantity inputs
      document.querySelectorAll(".quantity-input").forEach((input) => {
        const itemId = input.dataset.itemId;
        
        // Find the corresponding cart item in our data
        const itemData = cartItems.find(
          (item) => item.id === itemId || item.item_id === itemId
        );
        if (!itemData) return;
        
        const price = itemData.product?.price || itemData.unit_price || 0;
        const maxQuantity = itemData.product?.inventory || 10;
        
        // Handle input change
        input.addEventListener("change", async () => {
          let newQty = parseInt(input.value);
          if (isNaN(newQty) || newQty < 1) {
            newQty = 1;
            input.value = 1;
          }
          if (newQty > maxQuantity) {
            newQty = maxQuantity;
            input.value = maxQuantity;
          }
          
          try {
            await cart.updateCartItem(userCart.id, itemId, newQty);
            
            // Update the item subtotal
            const cartItem = input.closest(".cart-item");
            const subtotalEl = cartItem.querySelector(".mt-3 .font-medium");
            if (subtotalEl) {
              subtotalEl.textContent = formatPrice(newQty * price);
            }
            
            // Update cart total
            updateCartTotal();
          } catch (error) {
            console.error("Failed to update quantity:", error);
            alert("Failed to update quantity");
          }
        });
      });
      
      // Handle decrease buttons
      document.querySelectorAll(".decrease-quantity-btn").forEach((button) => {
        const itemId = button.dataset.itemId;
        const input = document.querySelector(`.quantity-input[data-item-id="${itemId}"]`);
        if (!input) return;
        
        // Find the corresponding cart item in our data
        const itemData = cartItems.find(
          (item) => item.id === itemId || item.item_id === itemId
        );
        if (!itemData) return;
        
        const price = itemData.product?.price || itemData.unit_price || 0;
        
        button.addEventListener("click", async () => {
          let currentQty = parseInt(input.value);
          if (currentQty <= 1) return;
          
          const newQty = currentQty - 1;
          input.value = newQty;
          
          try {
            await cart.updateCartItem(userCart.id, itemId, newQty);
            
            // Update the item subtotal
            const cartItem = button.closest(".cart-item");
            const subtotalEl = cartItem.querySelector(".mt-3 .font-medium");
            if (subtotalEl) {
              subtotalEl.textContent = formatPrice(newQty * price);
            }
            
            // Update cart total
            updateCartTotal();
          } catch (error) {
            console.error("Failed to decrease quantity:", error);
            input.value = currentQty; // Revert on error
            alert("Failed to update quantity");
          }
        });
      });
      
      // Handle increase buttons
      document.querySelectorAll(".increase-quantity-btn").forEach((button) => {
        const itemId = button.dataset.itemId;
        const input = document.querySelector(`.quantity-input[data-item-id="${itemId}"]`);
        if (!input) return;
        
        // Find the corresponding cart item in our data
        const itemData = cartItems.find(
          (item) => item.id === itemId || item.item_id === itemId
        );
        if (!itemData) return;
        
        const price = itemData.product?.price || itemData.unit_price || 0;
        const maxQuantity = itemData.product?.inventory || 10;
        
        button.addEventListener("click", async () => {
          let currentQty = parseInt(input.value);
          if (currentQty >= maxQuantity) return;
          
          const newQty = currentQty + 1;
          input.value = newQty;
          
          try {
            await cart.updateCartItem(userCart.id, itemId, newQty);
            
            // Update the item subtotal
            const cartItem = button.closest(".cart-item");
            const subtotalEl = cartItem.querySelector(".mt-3 .font-medium");
            if (subtotalEl) {
              subtotalEl.textContent = formatPrice(newQty * price);
            }
            
            // Update cart total
            updateCartTotal();
          } catch (error) {
            console.error("Failed to increase quantity:", error);
            input.value = currentQty; // Revert on error
            alert("Failed to update quantity");
          }
        });
      });
      
      // Handle remove buttons
      document.querySelectorAll(".remove-item-btn").forEach((button) => {
        const itemId = button.dataset.itemId;
        
        button.addEventListener("click", async () => {
          if (confirm("Are you sure you want to remove this item from your cart?")) {
            try {
              await cart.removeFromCart(userCart.id, itemId);
              
              // Remove the item from the UI
              const cartItem = button.closest(".cart-item");
              cartItem.remove();
              
              // Update cart total
              updateCartTotal();
              
              // If no items left, show empty cart message
              if (document.querySelectorAll(".cart-item").length === 0) {
                const cartItemsContainer = document.getElementById("cart-items");
                if (cartItemsContainer) {
                  cartItemsContainer.innerHTML = `
                    <div class="p-8 text-center">
    console.error("Error processing checkout:", error);
    checkoutContainer.innerHTML = `<p class="text-center">Error processing checkout: ${error.message}</p>`;
  }
}

// Function to generate a UUID (for the demo)
function uuid() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
    var r = (Math.random() * 16) | 0,
      v = c === "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

// Apply promotions to cart items according to the test requirements
function applyPromotions(cartItems) {
  const checkout = {
    id: uuid(),
    items: [...cartItems],
    promotions: [],
    subtotal: 0,
    total_discount: 0,
    total: 0,
  };

  // Calculate initial subtotal
  checkout.subtotal = cartItems.reduce(
    (total, item) => total + item.subtotal,
    0
  );
  checkout.total = checkout.subtotal;

  // 1. Each sale of a MacBook Pro comes with a free Raspberry Pi B
  const macbookPromotion = applyMacbookPromotion(cartItems);
  if (macbookPromotion.discount > 0) {
    checkout.promotions.push(macbookPromotion);
    checkout.total_discount += macbookPromotion.discount;
  }

  // 2. Buy 3 Google Homes for the price of 2
  const googleHomePromotion = applyGoogleHomePromotion(cartItems);
  if (googleHomePromotion.discount > 0) {
    checkout.promotions.push(googleHomePromotion);
    checkout.total_discount += googleHomePromotion.discount;
  }

  // 3. Buying more than 3 Alexa Speakers will get a 10% discount on all Alexa speakers
  const alexaPromotion = applyAlexaPromotion(cartItems);
  if (alexaPromotion.discount > 0) {
    checkout.promotions.push(alexaPromotion);
    checkout.total_discount += alexaPromotion.discount;
  }

  // Calculate final total
  checkout.total = checkout.subtotal - checkout.total_discount;

  return checkout;
}

// Apply MacBook Pro promotion - each MacBook Pro comes with a free Raspberry Pi B
function applyMacbookPromotion(cartItems) {
  const macbooks = cartItems.find((item) => item.product_sku === "43N23P");
  const raspberryPis = cartItems.find((item) => item.product_sku === "234234");

  const promotion = {
    id: uuid(),
    description: "Each sale of a MacBook Pro comes with a free Raspberry Pi B",
    discount: 0,
  };

  if (!macbooks || !raspberryPis) {
    return promotion;
  }

  // The number of free Raspberry Pis equals the number of MacBooks purchased
  // but is limited by the number of Raspberry Pis in the cart
  const freeItems = Math.min(macbooks.quantity, raspberryPis.quantity);

  if (freeItems > 0) {
    promotion.discount = freeItems * raspberryPis.unit_price;
  }

  return promotion;
}

// Apply Google Home promotion - Buy 3 Google Homes for the price of 2
function applyGoogleHomePromotion(cartItems) {
  const googleHomes = cartItems.find((item) => item.product_sku === "120P90");

  const promotion = {
    id: uuid(),
    description: "Buy 3 Google Homes for the price of 2",
    discount: 0,
  };

  if (!googleHomes || googleHomes.quantity < 3) {
    return promotion;
  }

  // For every 3 Google Homes, 1 is free
  const sets = Math.floor(googleHomes.quantity / 3);
  promotion.discount = sets * googleHomes.unit_price;

  return promotion;
}

// Apply Alexa Speaker promotion - Buying more than 3 gets a 10% discount on all
function applyAlexaPromotion(cartItems) {
  const alexaSpeakers = cartItems.find((item) => item.product_sku === "A304SD");

  const promotion = {
    id: uuid(),
    description: "10% discount on Alexa Speakers when buying more than 3",
    discount: 0,
  };

  if (!alexaSpeakers || alexaSpeakers.quantity <= 3) {
    return promotion;
  }

  // 10% discount on all Alexa speakers
  promotion.discount = alexaSpeakers.subtotal * 0.1;

  return promotion;
}

// Render the checkout with applied promotions
function renderCheckout(checkout, container) {
  const itemsHtml = checkout.items
    .map((item) => {
      return `
      <div class="checkout-item">
        <div class="checkout-item-info">
          <h3>${item.product_name}</h3>
          <p class="sku">SKU: ${item.product_sku}</p>
          <p>Price: $${parseFloat(item.unit_price).toFixed(2)}</p>
          <p>Quantity: ${item.quantity}</p>
          <p>Subtotal: $${parseFloat(item.subtotal).toFixed(2)}</p>
        </div>
      </div>
    `;
    })
    .join("");

  const promotionsHtml = checkout.promotions.length
    ? checkout.promotions
        .map(
          (promotion) => `
          <div class="promotion-item">
            <p><strong>${promotion.description}</strong></p>
            <p class="discount">-$${parseFloat(promotion.discount).toFixed(
              2
            )}</p>
          </div>
        `
        )
        .join("")
    : `<p>No promotions applied</p>`;

  container.innerHTML = `
    <div class="checkout-summary-container">
      <div class="checkout-items">
        <h2>Items</h2>
        ${itemsHtml}
      </div>
      <div class="checkout-summary">
        <h2>Order Summary</h2>
        <div class="summary-detail">
          <p>Subtotal:</p>
          <p>$${parseFloat(checkout.subtotal).toFixed(2)}</p>
        </div>
        
        <div class="promotions-section">
          <h3>Applied Promotions</h3>
          ${promotionsHtml}
        </div>
        
        <div class="summary-detail total-discount ${
          checkout.total_discount > 0 ? "has-discount" : ""
        }">
          <p>Total Discount:</p>
          <p>-$${parseFloat(checkout.total_discount).toFixed(2)}</p>
        </div>
        
        <div class="summary-detail grand-total">
          <p>Total:</p>
          <p>$${parseFloat(checkout.total).toFixed(2)}</p>
        </div>
        
        <div class="checkout-actions">
          <a href="cart.html" class="btn btn-secondary">Back to Cart</a>
          <button class="btn btn-primary place-order-btn">Place Order</button>
        </div>
      </div>
    </div>
  `;

  // Add event listener for place order button
  const placeOrderBtn = container.querySelector(".place-order-btn");
  if (placeOrderBtn) {
    placeOrderBtn.addEventListener("click", () => {
      alert("Order placed successfully!");
      window.location.href = "products.html";
    });
  }
}

// Debug function to help identify issues with checkout
function debugCart() {
  try {
    // Check for current user
    const user = auth.getCurrentUser();
    console.log("Current user:", user);

    // Try to get current cart
    fetch(`${API_BASE_URL}/carts/me`, {
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${localStorage.getItem("token")}`,
      },
    })
      .then((response) => response.json())
      .then((data) => {
        console.log("Current user cart:", data);

        // Check cart items if available
        if (data.data && data.data.id) {
          const cartId = data.data.id;

          // Try to inspect individual cart items
          if (data.data.items && data.data.items.length > 0) {
            console.log("Cart items:", data.data.items);

            // Check for potential soft-deleted items
            const itemIds = data.data.items.map((item) => item.id);
            console.log("Item IDs to check:", itemIds);
          }

          // Try to diagnose checkout issues
          console.log(
            "Attempting to diagnose checkout issues for cart:",
            cartId
          );

          // Test checkout API directly
          fetch(`${API_BASE_URL}/checkouts`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${localStorage.getItem("token")}`,
            },
            body: JSON.stringify({
              cart_id: cartId,
            }),
          })
            .then((checkoutResponse) => {
              console.log("Checkout API test status:", checkoutResponse.status);
              return checkoutResponse.json();
            })
            .then((checkoutData) => {
              console.log("Checkout API test response:", checkoutData);
            })
            .catch((error) => {
              console.error("Checkout API test error:", error);
            });
        }
      })
      .catch((error) => {
        console.error("Cart debug error:", error);
      });
  } catch (error) {
    console.error("Debug function error:", error);
  }
}

// Create a global debug function
window.debugCartIssues = debugCart;

// Run initialization when DOM is loaded
document.addEventListener("DOMContentLoaded", initPage);

// Helper function to format price in USD format
function formatPrice(price) {
  return "USD " + parseFloat(price).toFixed(2);
}
